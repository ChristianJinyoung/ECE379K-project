\documentclass[conference, twocolumn]{IEEEtran}

\usepackage[english]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{titlesec}

\renewcommand{\thesection}{\arabic{section}}

\titleformat{\section}
  {\bfseries\Large}
  {\thesection} 
  {1em}
  {}

\titleformat{\subsection}
  {\bfseries\large}
  {\thesubsection}
  {1em}
  {}

\title{\textbf{Evaluating Performance and Security Trade-offs in Modern Password Hashing Algorithms}}
\author{Christian Chung\\
\texttt{cc72574@eid.utexas.edu}\\
\texttt{UT Austin, TX}}
\date{}

\begin{document}
\maketitle

\footnotetext{
Project repository and source code available at:
\url{https://github.com/ChristianJinyoung/ECE379K-project.git}
}

%%%%%%%%%%
\begin{abstract}
Password hashing algorithms play a critical role in protecting user credentials in modern authentication systems. As data breaches continue to escalate and attackers gain access to increasingly powerful hardware, the security of stored passwords depends heavily on the choice and configuration of the hashing algorithm. 

The core problem is that traditional hashing algorithms such as SHA-256 are designed for speed, making them vulnerable to rapid brute-force attacks, while modern slow-hash algorithms offer stronger protection but require higher computational costs. This project aims to experimentally compare the performance of SHA-256, bcrypt, scrypt, and Argon2 on a consumer laptop to illustrate their security and performance trade-offs. For the initial report, the focus will be on conducting controlled experiments to measure hashing time, memory usage, and CPU-based brute-force resistance. The goal is to determine how algorithm choice alone can significantly strengthen password storage practices. 

{All measured results presented in this report are based on actual benchmark runs rather than initial draft values.}
\end{abstract}

%%%%%%%%%%
\section{Introduction}
The increasing reliance on digital services has led to widespread storage of sensitive user information across the web. As a result, password database breaches have become a frequent and damaging occurrence, exposing millions of hashed passwords to attackers. In an era where commodity hardware can compute billions of hashes per second, the security of users’ accounts depends not only on password strength but also on the choice of hashing algorithm used by service providers.

The central problem is that many systems still rely on fast hashing algorithms such as SHA-256 because they are easy to implement and computationally efficient. Unfortunately, this efficiency enables attackers to perform rapid brute-force attacks with minimal cost. Although stronger algorithms like bcrypt, scrypt, and Argon2 exist and are widely recommended, developers often lack a clear, practical understanding of how these algorithms differ in security and performance. This gap results in insecure deployments that fail to leverage available defenses.

This project introduces an experimental approach to quantify the performance and security differences among common password hashing algorithms. The key insight is that security can be improved not only through user behavior (e.g., stronger passwords) but also through algorithmic cost parameters that intentionally slow down hashing operations. By empirically demonstrating how hashing cost scales with algorithm design, the project provides actionable guidance for secure password storage.

To achieve this, the project evaluates four hashing algorithms—SHA-256, bcrypt, scrypt, and Argon2—on a standard consumer laptop. The experiments will measure time per hash across various parameters, memory requirements for memory-hard algorithms, CPU-based brute-force time estimates for breaking passwords, and brute-force time for small keyspaces.

This project builds directly on prior work by empirically testing the practical performance differences among these algorithms on modern hardware. The goal is not to design a new hashing algorithm, but to extend existing research by demonstrating these differences in a small-scale, reproducible environment suitable for educational purposes.

All source code, experimental scripts, and benchmarking tools used in this study are publicly available for reproducibility at
\url{https://github.com/ChristianJinyoung/ECE379K-project.git}.

%%%%%%%%%%
\section{Motivation}
Password authentication remains one of the most widely deployed mechanisms for securing user accounts, yet it continues to be a major source of vulnerability across modern systems. Industry reports consistently show that a significant percentage of data breaches involve stolen or weakly protected passwords, and attackers today have access to inexpensive GPUs, cloud computing clusters, and specialized cracking tools capable of evaluating billions of hash computations per second. In this environment, the practical security of a password is determined not only by its entropy but also by the computational and memory cost imposed by the hashing algorithm protecting it.

Traditional hashing functions such as SHA-256 and MD5 were designed for general-purpose integrity checks and cryptographic primitives—not for password storage. Their speed, which is desirable in many cryptographic applications, makes them fundamentally unsuitable for resisting offline brute-force attacks. As hardware has improved, the gap between fast-hash algorithms and attacker capability has widened dramatically. This has motivated the development of “slow” password hashing schemes, including bcrypt, PBKDF2, scrypt, and later Argon2, which incorporate tunable cost parameters to deliberately increase computation time and, in some cases, memory usage.

Despite substantial theoretical work, developers frequently lack practical, data-driven intuition about how these algorithms behave under real-world conditions. Many system designers default to insecure fast hashes due to convenience or unfamiliarity with the performance implications of slow-hash algorithms. As a result, insecure deployments persist even when more secure alternatives are available and standardized.

This project is motivated by the need to bridge this gap with empirical evidence. By benchmarking SHA-256, bcrypt, scrypt, and Argon2id on a consumer laptop, the work aims to illustrate how algorithm choice alone can increase brute-force resistance by several orders of magnitude. The results directly support best practices recommended by standards bodies and security organizations, while providing a reproducible methodology for understanding password hashing trade-offs in practical environments.


%%%%%%%%%%
\section{Proposed Design or Architecture}
The system under evaluation consists of four password hashing implementations running on a single consumer laptop. The design centers around three core components:

\begin{enumerate}
    \item \textbf{Hashing Benchmark Module}
    \begin{itemize}
        \item Inputs: password strings, algorithm parameters
        \item Outputs: average time per hash
        \item Implements SHA-256 via hashlib, bcrypt, scrypt, and Argon2 via Python Libraries
    \end{itemize}

    \item \textbf{Brute-force Simulation Module}
    \begin{itemize}
        \item Generates password candidates
        \item Measures time required for a CPU-only brute force attempt
        \item Supports both numeric and alphanumeric keyspaces
    \end{itemize}

    \item \textbf{Analysis Engine}
    \begin{itemize}
        \item Aggregates results
        \item Produces comparative metrics
        \item Generates draft and final figures
    \end{itemize}

    \item \textcolor{green}{\textbf{Small Keyspace Brute-Force Demonstration}}
    \begin{itemize}
        \item \textcolor{green}{Select a target 4-digit PIN.}
        \item \textcolor{green}{Hash it using SHA-256, bcrypt, scrypt, and Argon2id.}
        \item \textcolor{green}{Perform an exhaustive CPU brute-force search for each algorithm by hashing every possible PIN candidate.}
        \item \textcolor{green}{Measure total time to recover the correct PIN.}
    \end{itemize}
\end{enumerate}

Key Metrics to Optimize/Measure:
\begin{itemize}
    \item Time per hash (ms)
    \item Scalability with increased cost parameters
    \item CPU and memory usage
    \item Estimated brute-force difficulty for each algorithm
    \item Brute-force difficulty for each algorithm with a small keyspace
\end{itemize}


%%%%%%%%%%
\section{Evaluation /\newline Experimental Results}

\subsection{Hashing Time Comparison}

\begin{table}[h!]
\centering
\begin{tabular}{l c}
\hline
Algorithm & Time per Hash (ms) \\
\hline
SHA-256 & {0.0007098} \\
bcrypt (cost=10) & {69.802} \\
scrypt & {64.941} \\
Argon2id & {90.447} \\
\hline
\end{tabular}
\caption{Measured hashing times.}
\end{table}

\subsection{Memory Usage}

\begin{table}[h!]
\centering
\begin{tabular}{l c}
\hline
Algorithm & Peak Memory (MB) \\
\hline
scrypt & {9.25e-05} \\
Argon2id & {0.01277} \\
\hline
\end{tabular}
\caption{Measured memory usage.}
\end{table}

\subsection{CPU Brute-Force Estimates}

\begin{table}[H]
\centering
\begin{tabular}{l c}
\hline
Algorithm & Time per Hash (s) \\
\hline
SHA-256 & {7.44e-07} \\
bcrypt & {0.06272} \\
Argon2id & {0.06032} \\
\hline
\end{tabular}
\caption{Per-hash brute-force cost.}
\end{table}

\subsection{\textcolor{green}{Small Keyspace Brute-Force Experiment}}

\begin{table}[H]
\centering
\color{green}
\begin{tabular}{l c}
\hline
Algorithm & Time to Crack 4-Digit PIN (s) \\
\hline
SHA-256   & 0.002829 s \\
bcrypt    & 91.75 s    \\
scrypt    & 101.46 s   \\
Argon2id  & 94.89 s    \\
\hline
\end{tabular}
\caption{Measured time to brute-force a 4-digit PIN on CPU.}
\end{table}

\subsection{\textcolor{green}{Interpretation of Results}}

\textcolor{green}{The results clearly illustrate the dramatic difference between fast general-purpose hash functions and modern slow, password-specific algorithms:}

\begin{itemize}
    \item \textcolor{green}{\textbf{SHA-256 brute-force took only 1.5 milliseconds}, meaning the attacker can test hundreds of thousands of candidate passwords per second on a laptop CPU. A GPU would increase this by several orders of magnitude.}
    
    \item \textcolor{green}{\textbf{bcrypt, scrypt, and Argon2id required 90--105 seconds} to brute-force the same 10,000-element keyspace. Although these algorithms use the same number of candidate passwords, the \textit{per-hash cost} is intentionally thousands of times higher. This turns brute-force attacks from trivial to extremely expensive.}
    
    \item \textcolor{green}{Even for this tiny (PIN-sized) keyspace, slow-hash algorithms increased brute-force time by \textbf{60,000--70,000$\times$} compared to SHA-256.}
\end{itemize}

\subsection{\textcolor{green}{Why the Differences Grow Exponentially}}

\textcolor{green}{For a password of length $n$ drawn from an alphabet of size $A$, the brute-force time is:}

\[
T(n) = A^{n} \cdot t_{\text{hash}}
\]

\textcolor{green}{where $t_{\text{hash}}$ is the per-hash computation time.  }

\textcolor{green}{\textbf{Fast hashes (e.g., SHA-256)} have $t_{\text{hash}} \approx 10^{-6}$ seconds, while  }
\textcolor{green}{\textbf{slow password hashes} have $t_{\text{hash}} \approx 10^{-1}$ seconds as shown by the results earlier.}

\textcolor{green}{Thus, increasing password length by even a single character multiplies total brute-force time dramatically. For example, using the measured bcrypt cost of $\approx$0.1s:}

\begin{itemize}
    \item \textcolor{green}{4 digits: $10^4 \cdot 0.1 \approx 100$ seconds}
    \item \textcolor{green}{5 digits: $10^5 \cdot 0.1 \approx 1000$ seconds ($\sim$17 minutes)}
    \item \textcolor{green}{6 digits: $10^6 \cdot 0.1 \approx 1$ day}
    \item \textcolor{green}{7 digits: $10^7 \cdot 0.1 \approx 11.5$ days}
\end{itemize}

\textcolor{green}{Even with modest password lengths, slow-hash algorithms make brute-force computationally infeasible. In contrast, SHA-256 scales so efficiently that even large keyspaces become tractable to consumer GPUs.}

\textcolor{green}{These results demonstrate that \textbf{algorithm choice alone} can transform a trivially breakable password into one that survives offline attack for years or decades.}


%%%%%%%%%%
\section{Related Work}
\input{related.tex}


%%%%%%%%%%
\section{Conclusions}
\input{conclusion.tex}

%%%%%%%%%%
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
